var net = require('net');

var MSGTYPE = require('./msgtype').MSGTYPE;
var Message = require('./message').Message;



/**
 * Represents a client connection to Diffusion
 */
var Client = function(callbacks) {
    if(callbacks !== undefined) {
	this._callbacks = callbacks;
    }
    else {
	this._callbacks = {};
    }
    this._listeners = [];

    this._connectionDetails = undefined;
    this._socket = undefined;
    this._connected = undefined;
    this._version = undefined;
    this._response = undefined;
    this._messageLengthSize = undefined;
    this._clientId = undefined;

    this._lastBuf = undefined;
    this._aliasMap = {};

    this._fragments = {};
};

Client.prototype.getClientId = function() {
    return this._clientId;
};
Client.prototype.isConnected = function() {
    return this._connected;
};
Client.prototype.getVersion = function() {
    return this._version;
};
Client.prototype.response = function() {
    return this._response;
};

Client.prototype._onClose = function() {
    this._connected = false;
    if(this._callbacks.onDisconnect !== undefined) {
	this._callbacks.onDisconnect.apply(this);
    }
};

Client.prototype._onHandshakeResponse = function(data) {
    this._socket.removeAllListeners('data');
    this._socket.on('data', this._onData.bind(this));

    if(data[0] !== 35) {
	throw "Unexpected protocol byte";
    }
    this._version = data[1];
    this._response = data[2];
    this._messageLengthSize = data[3];
    this._clientId = data.toString('utf-8', 4, data.length-1);
    this._connected = true;

    if(this._callbacks.onConnect !== undefined) {
	this._callbacks.onConnect.apply(this, [this._connected]);
    }
};

Client.prototype._findListeners = function(topic) {
    var listeners = [];

    if(this._listeners !== undefined) {
	for(var i in this._listeners) {
	    var re = this._listeners[i];
	    if(topic.match(re) !== null) {
		listeners.push(this._listeners[i]);
	    }
	}
    }
    
    return listeners;
};

Client.prototype._removeListeners = function(topic) {
    var newListeners = [];

    if(this._listeners !== undefined) {
	for(var i in this._listeners) {
	    var re = this._listeners[i];
	    if(topic.match(re) === null) {
		newListeners.push(re);
	    }
	}
    }

    this._listeners = newListeners;
};

Client.prototype._unfragment = function(message) {
    var headers = message.getHeaders();
    var topicName = headers.shift();
    var correlationId = headers.shift();
    var fragmentId = headers.shift();

    if(this._fragments[correlationId] === undefined) {
        this._fragments[correlationId] = [];
    }
    var idx = fragmentId.indexOf('/');
    if(idx != -1) {
        this._fragments[correlationId][0] = fragmentId.substring(idx+1);
        fragmentId = fragmentId.substring(0, idx);
    }
    
    this._fragments[correlationId][fragmentId] = message;
    
    var complete = true;
    for(var i = this._fragments[correlationId][0]; i > 0; i--) {
        if(this._fragments[correlationId][i] === undefined) {
            complete = false;
            break;
        }
    }
    
    if(complete) {
        var msg = new Message(message.getType() & ~0x40);
        var body = '';
        for(var i = 1; i <= this._fragments[correlationId][0]; i++) {
            var fragment = this._fragments[correlationId][i];
            if(i == 1) {
                msg.setHeaders(fragment.getHeaders());
                msg.getHeaders().unshift(topicName);
            }
            body += fragment.getBody();
        }
        msg.setBody(body);

        this._fragments[correlationId] = undefined;

        return msg;
    }
    else {
        return null;
    }
}

Client.prototype._onData = function(data) {
    var offset = 0;

    // Got the remains of a previous buffer?
    if(this._lastBuf !== undefined) {
	tmp = new Buffer(this._lastBuf.length + data.length);
	this._lastBuf.copy(tmp);
	data.copy(tmp, this._lastBuf.length);
	data = tmp;
	this._lastBuf = undefined;
    }

    while(offset < data.length) {

	// Must be able to read in the length of the message
	if(data.length - offset < this._messageLengthSize) {
	    this._lastBuf = new Buffer(data.length - offset);
	    data.copy(this._lastBuf,0,offset);
	    break;
	}

	var len;
	switch(this._messageLengthSize) {
	case 1:
	    len = data.readInt8(offset);
	    break;
	case 2:
	    len = data.readInt16BE(offset);
	    break;
	case 4:
	    len = data.readInt32BE(offset);
	    break;
	default:
	    throw 'Unknown message length size: ' + this._messageLengthSize;
	}

	// Check we have enough bytes to read in the rest of the message
	if(offset + len > data.length) {
	    this._lastBuf = new Buffer(data.length - offset);
	    data.copy(this._lastBuf, 0, offset);
	    break;
	}

	var msgBuf = data.slice(offset, offset + len);
        offset += msgBuf.length;

	var type = msgBuf[this._messageLengthSize];
	var encoding = msgBuf[this._messageLengthSize+1];
	var content = msgBuf.toString('utf-8', this._messageLengthSize+2);

	var parts = content.split('\u0001');	
	var headers;
	var body;

        if(parts.length === 1) {
            headers = [];
            body = parts[0];
        }
	else {
	    headers = parts[0].split('\u0002');
	    body = parts[1];
        }

	var message = new Message(type);
	message.setHeaders(headers);
	message.setBody(body);

        // Fragmented message?
        if(message.getType() & 0x40) {
            message = this._unfragment(message);
            if(message === undefined || message === null) {
                continue; // More parts needed
            }
        }

	switch(message.getType()) {
	case MSGTYPE.PING_CLIENT:
	    this._sendPingResponse(body);
	    break;
	case MSGTYPE.FETCH_RESPONSE:
	    var topic = message._parseTopic(this, message.getHeaders().shift());
	    message.setTopic(topic);
	    // TODO: Only return messages with matching headers?
	    break;
	case MSGTYPE.LOAD:
	case MSGTYPE.DELTA:
	case MSGTYPE.LOAD_ACK:
	case MSGTYPE.DELTA_ACK:
	    var topic = message._parseTopic(this, message.getHeaders().shift());
	    message.setTopic(topic);
            
	    if(message.getType() == MSGTYPE.LOAD_ACK || message.getType() == MSGTYPE.DELTA_ACK) {
		var ackId = message.getHeaders().shift();
		this._sendAckResponse(ackId);
	    }

	    var handled = false;
	    var listeners = this._findListeners(topic);
	    for(var i in listeners) {
		handled = listeners[i].listener(topic);
		if(handled) {
		    break;
		}
	    }

	    if(!handled && this._callbacks.onMessage !== undefined) {
		this._callbacks.onMessage(message);
	    }
	    break;
        case MSGTYPE.ABORT:
            this._isConnected = false;
            break;
        case MSGTYPE.COMMAND_TOPIC_LOAD:
            console.log('Command topic load');
            break;
	default:
	    throw 'Unknown message type ' + String(message.getType());
	}
	
	offset += msgBuf.length;

    }
};

Client.prototype._sendPingResponse = function(timestamp) {
    var msg = new Message(MSGTYPE.PING_CLIENT);
    msg.setBody(timestamp + '\u0001');
    this.sendMessage(msg);
};

Client.prototype._sendAckResponse = function(ackId) {
    var msg = new Message(MSGTYPE.ACK);
    msg.setHeaders([ackId]);
    this.sendMessage(msg);
};

Client.prototype.connect = function(connectionDetails) {
    if(this._connected) {
	return;
    }

    this._connectionDetails = connectionDetails;

    if(this._connectionDetails === undefined) {
	this._connectionDetails = {
	    host: 'localhost',
	    port: 8080
	};
    }

    this._socket = net.connect(this._connectionDetails.port, this._connectionDetails.host);

    this._socket.on('close', this._onClose.bind(this));
    this._socket.on('data', this._onHandshakeResponse.bind(this));

    var handshake = '\u0023\u0004';

    if(this._connectionDetails.event_publisher) {
        handshake += '\u0001';
    }
    else {
        handshake += '\u0014';
    }
    handshake += '\u0000';

    var creds = [];
    if(this._connectionDetails.username !== undefined) {
        creds.push(this._connectionDetails.username);
    }
    if(this._connectionDetails.password !== undefined) {
        creds.push(this._connectionDetails.password);
    }
    if(creds.length > 0) {
        handshake += creds.join('\u0002');
        handshake += '\u0001';
    }
    handshake += '\u0000';
    
    this._socket.write(handshake);
};

Client.prototype.sendMessage = function(msg) {
    if(!this.isConnected()) {
	throw 'Not connected';
    }

    var length = this._messageLengthSize + 1 + 1;

    var topic = msg.getTopic();
    if(topic !== undefined) {
	msg._headers.unshift(topic);
    }

    var headerLength = msg.getHeaderLength();
    var bodyLength = msg.getBodyLength();

    length += headerLength + bodyLength;

    var buf = '';
    switch(this._messageLengthSize) {
    case 1:
	buf = String.fromCharCode(length);
	break;
    case 2:
	buf = String.fromCharCode((length >> 8) & 255)
	    + String.fromCharCode(length & 255);
	break;
    case 4:
	buf = String.fromCharCode(length >> 24)
	    + String.fromCharCode((length >> 16) & 255)
	    + String.fromCharCode((length >> 8) & 255)
	    + String.fromCharCode(length & 255);
	break;
    default:
	throw "Unknown message length size " + this._messageLengthSize + " for message length " + length;
    }

    buf += String.fromCharCode(msg._type);
    buf += '\u0000'; // No encoding

    for(var i in msg._headers) {
	if(i > 0) {
	    buf += '\u0002';
	}
	buf += msg._headers[i];
    }
    if(msg._headers.length > 0) {
	buf += '\u0001';
    }

    buf += msg._body;

    this._socket.write(buf);
};

Client.prototype.subscribe = function(topic, listener) {
    var message = new Message(MSGTYPE.SUBSCRIBE);
    message.getHeaders().push(topic);

    if(listener !== undefined) {
	var pattern;
	if(topic === '//') {
	    pattern = '.*';
	}
	// Turns a/b// into a/b/.*|a/b
	else if(topic.length >= 2 && topic.indexOf('//') === topic.length-2) {
	    pattern = '(' + topic.substring(0,topic.length-2) + '/.*|' + topic.substring(0,topic.length-2) + ')';
	}
	// Turns a/b/ into a/b/.*
	else if(topic.length >= 1 && topic.indexOf('/') === topic.length-1) {
	    pattern = topic + '.*';
	}
	// Anything else
	else {
	    pattern = topic;
	}
	var regexp = new RegExp(pattern);
	regexp.listener = listener;
	this._listeners.push(regexp);
    }

    this.sendMessage(message);
};

Client.prototype.unsubscribe = function(topic) {
    var message = new Message(MSGTYPE.UNSUBSCRIBE);
    message.getHeaders().push(topic);

    this._removeListeners(topic);

    this.sendMessage(message);
};

Client.prototype.fetch = function(topic, headers, listener) {
    var message = new Message(MSGTYPE.FETCH);
    message.getHeaders().push(topic);
    if(headers !== undefined) {
	message.getHeaders().push(headers);
    }

    this.sendMessage(message);
};

Client.prototype.sendCredentials = function(username, password) {
    var message = new Message(MSGTYPE.CREDENTIALS);
    message.getHeaders().push(username);
    message.getHeaders().push(password);
    this.sendMessage(message);
};

module.exports = {
    Client : Client
};
